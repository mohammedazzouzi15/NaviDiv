# Generated by Copilot
import logging
from collections import Counter

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from rdkit import Chem


class BaseScore:
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        output_path: str | None = None,
    ) -> None:
        """Initialize the BaseScore class.

        Args:
            min_count_fragments (int): Minimum count of fragments to consider.
            output_path (str | None): Path to save output files.
        """
        self._output_path = output_path
        self._csv_name = "fragments"
        self._fragments_df = None
        self._min_count_fragments = 3
        self.overrepresented_fragments_min_perc = 20
        self.overrepresented_fragments = None

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        raise NotImplementedError(
            "get_count method must be implemented in subclasses."
        )

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        raise NotImplementedError(
            "_comparison_function method must be implemented in subclasses."
        )

    def additional_metrics(self):
        """Calculate additional metrics for the fragments."""
        return {}

    def add_score_metrics(
        self, smiles_list: list[str], scores: list[float]
    ) -> pd.DataFrame:
        """Add score metrics to the DataFrame.

        Args:
            smiles_list (list[str]): List of generated SMILES strings.
            scores (list[float]): List of scores for the generated SMILES.

        Returns:
            pd.DataFrame: DataFrame with score metrics.
        """

        def process_fragment(
            fragment: str, smiles: list[str], scores: list[float]
        ) -> list[float]:
            # frag_mol = Chem.MolFromSmarts(fragment)
            # if frag_mol is None:
            #    return [0.0] * 9
            mol_score = [
                (sm, score)
                for score, sm in zip(scores, smiles, strict=False)
                if sm != "None"# and Chem.MolFromSmiles(sm) is not None
            ]
            scores_all = [score for _, score in mol_score]

            scores_containing_fragment = [
                score
                for smiles, score in mol_score
                if self._comparison_function(smiles=smiles, fragment=fragment)
            ]
            scores_not_containing_fragment = [
                score
                for smiles, score in mol_score
                if not self._comparison_function(
                    smiles=smiles, fragment=fragment
                )
            ]

            if len(scores_containing_fragment) == 0:
                return [0.0] * 9
            try:
                mean_score = np.mean(scores_all)
                std_score = np.std(scores_all)
                mean_score_fragment = np.mean(scores_containing_fragment)
                std_score_fragment = np.std(scores_containing_fragment)
                median_score = np.median(scores_all)
                median_score_fragment = np.median(scores_containing_fragment)
                mean_score_not_fragment = np.mean(
                    scores_not_containing_fragment
                )
                std_score_not_fragment = np.std(scores_not_containing_fragment)
                median_score_not_fragment = np.median(
                    scores_not_containing_fragment
                )
            except (ValueError, TypeError):
                logging.exception(
                    "Error calculating score metrics for fragment: %s",
                    fragment,
                )
                return [0.0] * 9
            return [
                mean_score,
                std_score,
                mean_score_fragment,
                std_score_fragment,
                median_score,
                median_score_fragment,
                mean_score_not_fragment,
                std_score_not_fragment,
                median_score_not_fragment,
            ]

        self._fragments_df = self._fragments_df[
            self._fragments_df["Count"] > self._min_count_fragments
        ]
        if self._fragments_df.shape[0] == 0:
            logging.warning(
                "No fragments found with count greater than %d",
                self._min_count_fragments,
            )
            return self._fragments_df
        self._fragments_df[
            [
                "mean_score",
                "std_score",
                "mean_score_fragment",
                "std_score_fragment",
                "median_score",
                "median_score_fragment",
                "mean_score_not_fragment",
                "std_score_not_fragment",
                "median_score_not_fragment",
            ]
        ] = self._fragments_df.apply(
            lambda row: pd.Series(
                process_fragment(
                    row["Substructure"],
                    smiles_list,
                    scores,
                )
            ),
            axis=1,
        )
        self._fragments_df["diff_median_score"] = (
            self._fragments_df["median_score_fragment"]
            - self._fragments_df["median_score_not_fragment"]
        )
        self._fragments_df.to_csv(
            f"{self._output_path}/{self._csv_name}_with_score.csv", index=False
        )
        return self._fragments_df

    def plot_count_histogram(
        self,
        title: str = "Fragment Count Histogram",
        xlabel: str = "Fragment Count",
        ylabel: str = "Frequency",
        bins: int = 50,
    ) -> None:
        """Plot a histogram of fragment counts.

        Args:
            title (str): Title of the histogram.
            xlabel (str): Label for the x-axis.
            ylabel (str): Label for the y-axis.
            bins (int): Number of bins in the histogram.
        """
        if self._fragments_df is None:
            raise ValueError("Fragments DataFrame is not initialized.")
        fig, ax = plt.subplots()
        ax = self._fragments_df["Count"].plot.hist(
            bins=bins,
            alpha=0.7,
            color="blue",
            edgecolor="black",
            ax=ax,
        )
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.set_title(title)
        plt.savefig(f"{self._output_path}/{self._csv_name}_histogram.png")
        plt.close(fig)

    def get_score(self, smiles_list: list[str], scores: list[float],additional_columns_df:{} = {}) -> pd.DataFrame:
        """Get the score for the fragments.

        Args:
            smiles_list (list[str]): List of generated SMILES strings.
            scores (list[float]): List of scores for the generated SMILES.

        Returns:
            pd.DataFrame: DataFrame with score metrics.
        """
        self.get_count(smiles_list)
        unique_fragments = self._fragments_df.shape[0]
        self.add_score_metrics(smiles_list, scores)

        unicity_ratio = unique_fragments / self.total_number_of_fragments
        for col,value in additional_columns_df.items():
            self._fragments_df[col] = value
        over_represented_fragments = self._fragments_df[
            self._fragments_df["Count_perc_per_molecule"]
            > self.overrepresented_fragments_min_perc
        ].shape[0]
        if self.overrepresented_fragments is None:
            self.overrepresented_fragments = self._fragments_df[
                self._fragments_df["Count_perc_per_molecule"]
                > self.overrepresented_fragments_min_perc
            ]
        self.overrepresented_fragments = pd.concat(
            [
                self.overrepresented_fragments,
                self._fragments_df[
                    self._fragments_df["Count_perc_per_molecule"]
                    > self.overrepresented_fragments_min_perc
                ],
            ]
        )
        dict_results = {
            "Unicity Ratio": unicity_ratio,
            "Total Number of Fragments": self.total_number_of_fragments,
            "Unique Fragments": unique_fragments,
            "Over Represented Fragments": over_represented_fragments,
        }
        dict_results = {**dict_results, **self.additional_metrics()}

        return dict_results

    def _from_list_to_count_df(
        self,
        smiles_list: list[str],
        substructure_list: list[str],
        total_number_of_ngrams: int | None = None,
    ) -> tuple[pd.DataFrame, None]:
        ngrams_counter = Counter(substructure_list)
        if total_number_of_ngrams is None:
            total_number_of_ngrams = len(substructure_list)
        self.total_number_of_fragments = total_number_of_ngrams
        ngrams_df = pd.DataFrame(
            {
                "Substructure": list(ngrams_counter.keys()),
                "Count": list(ngrams_counter.values()),
            }
        )
        ngrams_df["Count_perc"] = (
            ngrams_df["Count"] / total_number_of_ngrams
        ) * 100
        ngrams_df = ngrams_df.sort_values(by="Count_perc", ascending=False)
        ngrams_df = ngrams_df.reset_index(drop=True)
        ngrams_df["count_per_molecule"] = ngrams_df["Substructure"].apply(
            lambda x: self._cout_substructure_in_smiles(smiles_list, x)
        )

        ngrams_df["Count_perc_per_molecule"] = (
            ngrams_df["count_per_molecule"] / len(smiles_list)
        ) * 100
        if self._output_path:
            try:
                ngrams_df.to_csv(
                    f"{self._output_path}/{self._csv_name}.csv",
                    index=False,
                )
            except OSError:
                logging.exception(
                    "Error saving fragments CSV for output_path: %s",
                    self._output_path,
                )
        self._fragments_df = ngrams_df
        return ngrams_df, None

    def _cout_substructure_in_smiles(self, smiles, ngram):
        """Check if ngram is in smiles"""
        raise NotImplementedError(
            "_subs_in_smiles method must be implemented in subclasses."
        )
