# Generated by Copilot

import numpy as np
import pandas as pd
from rdkit import Chem, DataStructs
from rdkit.Chem import rdFingerprintGenerator

from navidiv.scorer import BaseScore


def get_fingerprints(molecules):
    """Generate Morgan fingerprints for a list of molecules."""
    mfpgen = rdFingerprintGenerator.GetMorganGenerator(
        radius=5, fpSize=2048, countSimulation=True
    )
    fingerprints = [mfpgen.GetFingerprint(mol) for mol in molecules]
    return fingerprints


def calculate_similarity(fp_list1, fp_list2):
    """Calculate the Tanimoto similarity between two sets of fingerprints."""
    return np.array(
        [DataStructs.BulkTanimotoSimilarity(fp1, fp_list2) for fp1 in fp_list1]
    )


class OriginalSimScorer(BaseScore):
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        threshold: float = 0.8,
        output_path: str | None = None,
        smiles_list_to_compare_to: list[str] | None = None,
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
        """
        super().__init__(output_path=output_path)
        self._csv_name = "Original_similarity"
        self._similarity = []
        self.threshold = threshold
        self._min_count_fragments = 0
        self.smiles_list_to_compare_to = smiles_list_to_compare_to
        self.original_fps = get_fingerprints(
            [
                Chem.MolFromSmiles(smiles)
                for smiles in smiles_list_to_compare_to
                if smiles != "None"
            ]
        )

    def get_clusters(self, similarity):
        """Get clusters of similar molecules based on a similarity threshold."""
        # np.fill_diagonal(similarity, 0)
        clusters = set()

        for i in range(similarity.shape[0]):
            if not np.any(similarity[i, :] > self.threshold):
                clusters.add(i)
        return clusters

    def _get_max_similarity(self, smiles: str) -> float:
        """Get the maximum similarity of a molecule to the original dataset."""
        if not hasattr(self, "_smiles_list"):
            raise ValueError(
                "SMILES list has not been calculated. Please run get_count first."
            )

        if smiles in self._smiles_list:
            smiles_index = self._smiles_list.index(smiles)
        else:
            return 0.0
        return np.max(self._similarity_to_original[smiles_index, :])

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        if not hasattr(self, "_mol_smiles"):
            self._mol_smiles = [
                Chem.MolFromSmiles(smiles)
                for smiles in smiles_list
                if smiles != "None"
            ]
            self._mol_smiles = [
                mol for mol in self._mol_smiles if mol is not None
            ]
            self._smiles_list = [
                smiles
                for smiles in smiles_list
                if smiles
                != "None"  # and Chem.MolFromSmiles(smiles) is not None
            ]

            # print("Number of valid molecules:", len(self._mol_smiles))
        search_fps = get_fingerprints(self._mol_smiles)

        self._similarity_to_original = calculate_similarity(
            search_fps, self.original_fps
        )

        clusters = self.get_clusters(self._similarity_to_original)
        clusters_smiles = [self._smiles_list[i] for i in clusters]
        fragments, over_represented_fragments = self._from_list_to_count_df(
            self._smiles_list,
            clusters_smiles,
            total_number_of_ngrams=len(self._smiles_list),
        )
        self._fragments_df = fragments
        self._fragments_df["max_similarity"] = self._fragments_df[
            "Substructure"
        ].apply(lambda x: self._get_max_similarity(x))
        return fragments, over_represented_fragments

    def _count_substructure_in_smiles(self, smiles_list, ngram):
        ngram_index = self._smiles_list.index(ngram)
        # print(f"ngram_index: {self._similarity_to_original.shape}, ")
        return 1 + len(
            [
                i
                for i in range(self._similarity_to_original.shape[1])
                if self._similarity_to_original[ngram_index, i]
                > self.threshold
            ]
        )

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if teh smiles and fragment are similar to the same molecules in the original one."""
        return False
        fragment_index = self._smiles_list.index(fragment)
        smiles_index = self._smiles_list.index(smiles)
        if fragment_index is None or smiles_index is None:
            return False

        sim_smiles = {
            i
            for i in range(self._similarity_to_original.shape[1])
            if self._similarity_to_original[smiles_index, i] > self.threshold
        }
        sim_frag = {
            i
            for i in range(self._similarity_to_original.shape[1])
            if self._similarity_to_original[fragment_index, i] > self.threshold
        }
        if fragment_index == smiles_index and len(sim_frag) > 0:
            print(
                f"Fragment {fragment} {fragment_index} is similar to itself in the original dataset."
            )
            print(sim_frag, sim_smiles)
            raise ValueError(
                "The fragment is the same as the SMILES. This should not happen."
            )

        return bool(sim_smiles & sim_frag)

    def additional_metrics(self):
        """Calculate additional metrics for the scorer."""
        # np.fill_diagonal(self._similarity_to_itself, 0)
        mean_distance = np.mean(self._similarity_to_original)
        std_distance = np.std(self._similarity_to_original)
        return {
            "mean_distance": mean_distance,
            "std_distance": std_distance,
        }
