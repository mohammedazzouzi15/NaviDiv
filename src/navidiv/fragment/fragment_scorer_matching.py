# Generated by Copilot
import itertools
import logging
import random

import numpy as np
import pandas as pd
from rdkit import Chem, DataStructs
from rdkit.Chem import rdFingerprintGenerator, rdFMCS

from navidiv.scorer import BaseScore

MIN_COUNT_FRAGMENTS = 1


class FragmentMatchScorer(BaseScore):
    """Handles fragment scoring using matching approach and analysis for molecular datasets."""

    def __init__(
        self,
        min_count_fragments: int = MIN_COUNT_FRAGMENTS,
        output_path: str | None = None,
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
        """
        super().__init__(output_path=output_path)
        self.config = {
            "max_substructures": 20,
            "min_atoms": 12,
            "ring_matches_ring_only": True,
            "complete_rings_only": True,
            "similarity_threshold": 0.3,
        }
        self._min_count_fragments = min_count_fragments
        self._csv_name = "Fragments_Match"

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        mol_smiles = [
            Chem.MolFromSmiles(smiles)
            for smiles in smiles_list
            if smiles != "None"
        ]
        mol_smiles = [mol for mol in mol_smiles if mol is not None]
        fragments = []
        fragments = find_most_common_substructure(smiles_list, self.config)
        fragments, over_represented_fragments = self._from_list_to_count_df(
            smiles_list,
            fragments,
        )
        self._fragments_df = fragments
        return fragments, over_represented_fragments

    def _count_substructure_in_smiles(self, smiles_list, fragment):
        """Check if ngram is in smiles"""
        self._mol_smiles = [
            Chem.MolFromSmiles(smiles)
            for smiles in smiles_list
            if smiles != "None"
        ]
        self._mol_smiles = [
            mol for mol in self._mol_smiles if mol is not None
        ]
        return len(
            [
                mol
                for mol in self._mol_smiles
                if mol.HasSubstructMatch(Chem.MolFromSmarts(fragment))
            ]
        )

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        if smiles is None and mol is None:
            return False
        if smiles is not None:
            mol = Chem.MolFromSmiles(smiles)
        if fragment is None or mol is None:
            return False
        try:
            return mol.HasSubstructMatch(Chem.MolFromSmarts(fragment))
        except ValueError:
            logging.exception(
                "Error in substructure match for fragment: %s", fragment
            )
            return False


class CompareElementsOutsideRings(rdFMCS.MCSAtomCompare):
    def __call__(self, p, mol1, atom1, mol2, atom2):
        a1 = mol1.GetAtomWithIdx(atom1)
        a2 = mol2.GetAtomWithIdx(atom2)
        if a1.GetAtomicNum() != a2.GetAtomicNum() and not (
            a1.IsInRing() and a2.IsInRing()
        ):
            return False
        # if p.MatchChiralTag and not self.CheckAtomChirality(
        #    p, mol1, atom1, mol2, atom2
        # ):
        #    return False
        if p.RingMatchesRingOnly:
            return self.CheckAtomRingMatch(p, mol1, atom1, mol2, atom2)
        return True


def get_fingerprints(molecules):
    """Generate Morgan fingerprints for a list of molecules."""
    mfpgen = rdFingerprintGenerator.GetMorganGenerator(
        radius=5, fpSize=2048, countSimulation=True
    )
    fingerprints = [mfpgen.GetFingerprint(mol) for mol in molecules]
    return fingerprints


def calculate_similarity(fp_list1, fp_list2):
    """Calculate the Tanimoto similarity between two sets of fingerprints."""
    return np.array(
        [DataStructs.BulkTanimotoSimilarity(fp1, fp_list2) for fp1 in fp_list1]
    )


def find_most_common_substructure(smiles_list, config: dict) -> set[str]:
    """Find the most common substructure in a list of SMILES strings.

    Args:
        smiles_list (list[str]): List of SMILES strings.
        config (dict): Configuration dictionary with parameters for MCS search.
            - max_substructures (int): Maximum number of substructures to find.
            - min_atoms (int): Minimum number of atoms in the substructure.
            - ring_matches_ring_only (bool): Whether to match rings only with rings.
            - complete_rings_only (bool): Whether to consider only complete rings.
            - similiarity_threshold (float): Threshold for similarity to consider molecules as similar.

    Returns:
        set[str]: Set of SMARTS strings representing the most common substructures.
    """
    params = rdFMCS.MCSParameters()
    params.Verbose = False
    params.AtomTyper = CompareElementsOutsideRings()
    params.BondCompareParameters.RingMatchesRingOnly = config[
        "ring_matches_ring_only"
    ]
    params.BondCompareParameters.CompleteRingsOnly = config[
        "complete_rings_only"
    ]
    params.Timeout = 1  # seconds

    molecules = [
        Chem.MolFromSmiles(smiles)
        for smiles in smiles_list
        if Chem.MolFromSmiles(smiles) is not None
    ]
    molecules_filtered = []
    for mol in molecules:
        mol_copy = Chem.RemoveHs(mol)
        molecules_filtered.append(mol_copy)

    # remove Hs from the molecules
    molecules = molecules_filtered
    fingerptint = get_fingerprints(molecules)
    similarity_matrix = calculate_similarity(fingerptint, fingerptint)
    molecules_lists = []
    similarity_threshold = config.get("similarity_threshold", 0.3)
    for i, j, k in itertools.combinations(range(len(molecules)), 3):
        similarity_array = [
            similarity_matrix[i][j],
            similarity_matrix[i][k],
            similarity_matrix[j][k],
        ]
        #if all([x > similarity_threshold for x in similarity_array]):
        molecules_lists.append([molecules[i], molecules[j], molecules[k]])

    if not molecules:
        raise ValueError(
            "No valid molecules found in the dataset. Please check the input SMILES strings."
        )
    substructures = set()
    #print(f"will run the MCS search on {len(molecules_lists)} iterations")
    # random.shuffle(molecules_lists)
    if len(molecules_lists) == 0:
        raise ValueError(
            "No valid pairs of molecules found for MCS search. Please check the input SMILES strings."
        )
    random.shuffle(molecules_lists)
    for mols in molecules_lists:
        # print(f"Running MCS search on {len(mols)} molecules")
        #print(" Smiles: ", [Chem.MolToSmiles(mol) for mol in mols])

        mcs_result = rdFMCS.FindMCS(mols, params)  # , timeout=int(1000))

        mcs_mol = mcs_result.queryMol
        #print("number of subs so far", len(substructures))
        if mcs_mol is None or mcs_mol.GetNumAtoms() < config["min_atoms"]:
            continue
        substructures.add(mcs_result.smartsString)

        if len(substructures) > config["max_substructures"]:
            break

    return substructures
