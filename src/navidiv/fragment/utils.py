

import logging

from rdkit import Chem
from rdkit.Chem.Scaffolds import rdScaffoldNetwork


def GetRingSystems(mol, includeSpiro=False):
    ri = mol.GetRingInfo()
    systems = []
    for ring in ri.AtomRings():
        ringAts = set(ring)
        nSystems = []
        for system in systems:
            nInCommon = len(ringAts.intersection(system))
            if nInCommon and (includeSpiro or nInCommon > 1):
                ringAts = ringAts.union(system)
            else:
                nSystems.append(system)
        nSystems.append(ringAts)
        systems = nSystems
    ring_smi = []
    for system in systems:
        frag_smi = Chem.MolFragmentToSmiles(mol, system, canonical=True)
        ring_smi.append(frag_smi)
    return ring_smi


def get_fragments(mols: list[Chem.Mol], min_num_atoms) -> list[str]:
    """Extract fragments from a list of SMILES strings using MacFrag and fused ring fragmentation."""
    # params = rdScaffoldNetwork.BRICSScaffoldParams()
    # net = build_scaffold_network(mols, params)
    #    print("Scaffold network built with", len(net.nodes), "nodes")
    fragments = []
    for mol in mols:
        new_nodes_copy = get_fragment_not_in_scaffolds(mol, min_num_atoms)
        fragments.extend(new_nodes_copy)
    return fragments


def build_scaffold_network(mols, params=None):
    if params is None:
        params = rdScaffoldNetwork.ScaffoldNetworkParams()
        params.collectMolCounts = True
    try:
        net = rdScaffoldNetwork.CreateScaffoldNetwork(mols, params)
        return net
    except Exception as e:
        logging.exception("Error building scaffold network: %s", e)
        return None
        # raise ValueError("Failed to build scaffold network") from e


def remove_substructure(mol, substruct_smarts):
    """Remove a substructure (given as SMARTS) from a molecule.
    Returns a list of resulting molecule fragments (as Chem.Mol objects).
    If the substructure is not found, returns the original molecule in a list.
    Generated by Copilot.
    """
    patt = Chem.MolFromSmarts(substruct_smarts)
    if patt is None:
        raise ValueError("Invalid SMARTS pattern")
    matches = mol.GetSubstructMatch(patt)
    if not matches:
        return []
    # Remove the atoms in the match
    emol = Chem.EditableMol(mol)
    # Remove atoms in reverse order to avoid reindexing issues
    for idx in sorted(matches, reverse=True):
        emol.RemoveAtom(idx)
    frag_mol = emol.GetMol()
    # Split into fragments if disconnected
    frags = Chem.GetMolFrags(frag_mol, asMols=True, sanitizeFrags=False)
    return list(frags)


def get_fragment_not_in_scaffolds(mol, min_num_atoms) -> list[str]:
    """Get fragments of a molecule that are not present in the given scaffolds.
    Returns a list of fragments (as SMARTS).
    Generated by Copilot.
    """
    params = rdScaffoldNetwork.ScaffoldNetworkParams()
    params.includeGenericBondScaffolds = False
    params.includeGenericScaffolds = False
    params.flattenChirality = True
    params.includeScaffoldsWithoutAttachments = True

    fragments = set(
        [Chem.MolToSmiles(mol)]
    )  # Start with the original molecule
    net = build_scaffold_network([mol], params)
    if net is None:
        logging.error("Failed to build scaffold network for the molecule.")
        return []
    for scaffold in net.nodes:
        # if mol.HasSubstructMatch(Chem.MolFromSmiles(scaffold)):
        scaffold_mol = Chem.MolFromSmiles(scaffold)
        if scaffold_mol is None:
            continue
        if scaffold_mol.GetNumAtoms() >= min_num_atoms:
            fragments.add(scaffold)
        else:
            continue
        for frag in remove_substructure(mol, scaffold):
            if (
                # mol.HasSubstructMatch(frag)
                frag.GetNumAtoms() >= min_num_atoms
            ):
                fragments.add(Chem.MolToSmiles(frag))

    fragments = [
        smi for smi in fragments if Chem.MolFromSmiles(smi) is not None
    ]
    return fragments


def delete_non_ring_atoms(mol: Chem.Mol) -> Chem.Mol:
    """Delete non-ring atoms from the molecule."""
    atoms_to_delete = [
        atom.GetIdx() for atom in mol.GetAtoms() if not atom.IsInRing()
    ]
    mol_rw = Chem.RWMol(mol)
    mol_rw.BeginBatchEdit()
    for atom in atoms_to_delete:
        mol_rw.RemoveAtom(atom)
    mol_rw.CommitBatchEdit()
    return Chem.Mol(mol_rw)


def transform_molecules(mol: Chem.Mol, scaffold_mode_setting: str) -> Chem.Mol:
    """Transform a molecule into a scaffold based on the specified mode.

    the scaffold mode setting can be one of:
    - "basic_framework": Anonymize atoms and set all bonds to single.
    - "elemental_wire_frame": Set all bonds to single, keep atom types.
    - "basic_wire_frame": Set all atoms to carbon, keep bond orders.
    - "none": No transformation, return the original molecule.

    Args:
        mol (Chem.Mol): The input molecule.
        scaffold_mode_setting (str): The scaffold mode setting.

    Returns:
        Chem.Mol: The transformed molecule.

    Raises:
        ValueError: If the scaffold mode setting is unknown.
    """
    from rdkit.Chem.Scaffolds import MurckoScaffold

    if scaffold_mode_setting == "basic_framework":
        # Anonymize atoms and set all bonds to single
        scaffold = MurckoScaffold.GetScaffoldForMol(mol)
        try:
            scaffold = MurckoScaffold.MakeScaffoldGeneric(scaffold)
        except Exception as e:
            logging.error(
                "Error creating scaffold generic: %s. Returning original molecule.",
                e,
            )
            return mol
        return scaffold
    if scaffold_mode_setting == "elemental_wire_frame":
        # Set all bonds to single, keep atom types
        scaffold = MurckoScaffold.GetScaffoldForMol(mol)
        rw_scaffold = Chem.RWMol(scaffold)  # Make editable
        for bond in rw_scaffold.GetBonds():
            bond.SetBondType(Chem.BondType.SINGLE)
        scaffold_single = rw_scaffold.GetMol()
        Chem.SanitizeMol(scaffold_single)
        return scaffold_single
    if scaffold_mode_setting == "basic_wire_frame":
        # Set all atoms to carbon, keep bond orders
        scaffold = MurckoScaffold.GetScaffoldForMol(mol)
        for atom in scaffold.GetAtoms():
            atom.SetAtomicNum(6)
        return scaffold
    if scaffold_mode_setting == "none":
        # No transformation, return the original molecule
        return mol
