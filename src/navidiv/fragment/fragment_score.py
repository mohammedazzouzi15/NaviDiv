# Generated by Copilot
import logging
import numpy as np
import pandas as pd
from rdkit import Chem
from navidiv.fragment.utils import MacFrag
from navidiv.fragment.utils.misc import fragment_mols_fused_ring

DIFF_MEDIAN_SCOR_LIMIT = 0.2
MIN_COUNT_FRAGMENTS = 10
MAX_BLOCKS = 100
MAX_SR = 1
MIN_FRAG_ATOMS = 10
MAX_FRAGMENT_ATOMS = 40


class FragmentScore:
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        min_count_fragments: int = MIN_COUNT_FRAGMENTS,
        output_path: str | None = None,
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
        """
        self._min_count_fragments = min_count_fragments
        self._output_path = output_path
        self._fragments_df = None

    def get_count(
        self, smiles_list: list[str]
    ) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        fragments, over_represented_fragments = self.fragment_smiles_list(
            smiles_list
        )
        self._fragments_df = fragments
        return fragments, over_represented_fragments

    def fragment_smiles_list(
        self, smiles_list: list[str]
    ) -> tuple[pd.DataFrame, None]:
        """Fragment a list of SMILES strings into substructures.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with substructures, None (for compatibility)
        """
        mol_smiles = [
            Chem.MolFromSmiles(smiles)
            for smiles in smiles_list
            if smiles != "None"
        ]
        mol_smiles = [mol for mol in mol_smiles if mol is not None]
        fragments = set()
        for mol in mol_smiles:
            fragments.update(get_fragment(mol))
        fragments_df = pd.DataFrame(
            {
                "Substructure": list(fragments),
                "Count": [0] * len(fragments),
            }
        )
        fragments_df["smart_mol"] = [
            Chem.MolFromSmarts(smart)
            for smart in fragments_df["Substructure"]
        ]
        for smarts_mol in fragments_df["smart_mol"]:
            count = sum(
                1 for mol in mol_smiles if mol.HasSubstructMatch(smarts_mol)
            )
            fragments_df.loc[
                fragments_df["smart_mol"] == smarts_mol, "Count"
            ] = count
        fragments_df = fragments_df[fragments_df["Count"] > 0]
        fragments_df["count_perc"] = (
            fragments_df["Count"] / len(smiles_list)
        ) * 100
        fragments_df["smiles"] = [
            Chem.MolToSmiles(Chem.MolFromSmarts(smart))
            for smart in fragments_df["Substructure"]
        ]
        if self._output_path:
            try:
                fragments_df.to_csv(
                    f"{self._output_path}/fragments.csv", index=False
                )
            except OSError:
                logging.exception(
                    "Error saving fragments CSV for output_path: %s",
                    self._output_path,
                )
        self._fragments_df = fragments_df
        return fragments_df, None

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        if smiles is None and mol is None:
            return False
        if smiles is not None:
            mol = Chem.MolFromSmiles(smiles)
        if fragment is None or mol is None:
            return False
        try:
            return mol.HasSubstructMatch(Chem.MolFromSmarts(fragment))
        except ValueError:
            logging.exception(
                "Error in substructure match for fragment: %s", fragment
            )
            return False

    def add_score_metrics(
        self, smiles_list: list[str], scores: list[float]
    ) -> pd.DataFrame:
        """Add score metrics to the DataFrame.

        Args:
            smiles_list (list[str]): List of generated SMILES strings.
            scores (list[float]): List of scores for the generated SMILES.

        Returns:
            pd.DataFrame: DataFrame with score metrics.
        """
        def process_fragment(
            fragment: str, smiles: list[str], scores: list[float]
        ) -> list[float]:
            frag_mol = Chem.MolFromSmarts(fragment)
            if frag_mol is None:
                return [0.0] * 9
            mol_score = [
                (Chem.MolFromSmiles(sm), score)
                for score, sm in zip(scores, smiles, strict=False)
                if sm != "None" and Chem.MolFromSmiles(sm) is not None
            ]
            scores_all = [score for _, score in mol_score]
            scores_containing_fragment = [
                score
                for mol, score in mol_score
                if self._comparison_function(mol=mol, fragment=fragment)
            ]
            scores_not_containing_fragment = [
                score
                for mol, score in mol_score
                if not self._comparison_function(mol=mol, fragment=fragment)
            ]
            if len(scores_containing_fragment) == 0:
                return [0.0] * 9
            try:
                mean_score = np.mean(scores_all)
                std_score = np.std(scores_all)
                mean_score_fragment = np.mean(scores_containing_fragment)
                std_score_fragment = np.std(scores_containing_fragment)
                median_score = np.median(scores_all)
                median_score_fragment = np.median(scores_containing_fragment)
                mean_score_not_fragment = np.mean(
                    scores_not_containing_fragment
                )
                std_score_not_fragment = np.std(
                    scores_not_containing_fragment
                )
                median_score_not_fragment = np.median(
                    scores_not_containing_fragment
                )
            except (ValueError, TypeError):
                logging.exception(
                    "Error calculating score metrics for fragment: %s",
                    fragment,
                )
                return [0.0] * 9
            return [
                mean_score,
                std_score,
                mean_score_fragment,
                std_score_fragment,
                median_score,
                median_score_fragment,
                mean_score_not_fragment,
                std_score_not_fragment,
                median_score_not_fragment,
            ]

        self._fragments_df[
            [
                "mean_score",
                "std_score",
                "mean_score_fragment",
                "std_score_fragment",
                "median_score",
                "median_score_fragment",
                "mean_score_not_fragment",
                "std_score_not_fragment",
                "median_score_not_fragment",
            ]
        ] = self._fragments_df.apply(
            lambda row: pd.Series(
                process_fragment(
                    row["Substructure"],
                    smiles_list,
                    scores,
                )
            ),
            axis=1,
        )
        self._fragments_df["diff_median_score"] = (
            self._fragments_df["median_score_fragment"]
            - self._fragments_df["median_score_not_fragment"]
        )
        return self._fragments_df


def delete_non_ring_atoms(mol: Chem.Mol) -> Chem.Mol:
    """Delete non-ring atoms from the molecule."""
    atoms_to_delete = [
        atom.GetIdx() for atom in mol.GetAtoms() if not atom.IsInRing()
    ]
    mol_rw = Chem.RWMol(mol)
    mol_rw.BeginBatchEdit()
    for atom in atoms_to_delete:
        mol_rw.RemoveAtom(atom)
    mol_rw.CommitBatchEdit()
    return Chem.Mol(mol_rw)


def get_fragment(mol: Chem.Mol) -> list[str]:
    """Extract fragments from a molecule using MacFrag and fused ring fragmentation."""
    if mol is None:
        return []
    smarts_list = [
        Chem.MolToSmarts(mol_frag)
        for mol_frag in MacFrag(
            mol,
            maxBlocks=MAX_BLOCKS,
            maxSR=MAX_SR,
            asMols=True,
            minFragAtoms=MIN_FRAG_ATOMS,
        )
    ]
    fragments = set(smarts_list)
    for smarts in smarts_list:
        mol_frag = Chem.MolFromSmarts(smarts)
        if (
            mol_frag is not None
            and mol_frag.GetNumAtoms() < MAX_FRAGMENT_ATOMS
            and mol_frag.GetNumAtoms() > MIN_FRAG_ATOMS
        ):
            try:
                new_frag = fragment_mols_fused_ring(mol_frag)
                fragments.update(
                    [
                        Chem.MolToSmarts(frag)
                        for frag in new_frag
                        if frag is not None
                    ]
                )
            except (ValueError, TypeError):
                logging.exception(
                    "Error in fused ring fragmentation for fragment: %s",
                    smarts,
                )
                continue
    fragment_ring_only = [
        delete_non_ring_atoms(Chem.MolFromSmarts(fragment))
        for fragment in fragments
    ]
    fragments.update(
        [Chem.MolToSmarts(fragment) for fragment in fragment_ring_only]
    )
    fragments = [fragment for fragment in fragments if "." not in fragment]
    fragments = [
        fragment
        for fragment in fragments
        if len(fragment) > MIN_FRAG_ATOMS * 4
    ]
    mol_fragments = [
        Chem.MolFromSmarts(fragment)
        for fragment in fragments
        if Chem.MolFromSmarts(fragment) is not None
    ]
    fragments_cleaned = []
    for mol_fragment in mol_fragments:
        if mol_fragment is not None:
            try:
                if mol.HasSubstructMatch(mol_fragment):
                    fragments_cleaned.append(Chem.MolToSmarts(mol_fragment))
            except (ValueError, TypeError):
                logging.exception(
                    "Issue with fragment: %s; Error in matching fragment.",
                    Chem.MolToSmarts(mol_fragment),
                )
                continue
    return fragments_cleaned
