# Generated by Copilot
import logging
from collections import Counter

import pandas as pd
from rdkit import Chem

from navidiv.fragment.utils.Mac_frag import MacFrag
from navidiv.fragment.utils.misc import fragment_mols_fused_ring
from navidiv.scorer import BaseScore

DIFF_MEDIAN_SCOR_LIMIT = 0.2
MIN_COUNT_FRAGMENTS = 1
MAX_BLOCKS = 100
MAX_SR = 1
MIN_FRAG_ATOMS = 10
MAX_FRAGMENT_ATOMS = 40


class FragmentScorer(BaseScore):
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        min_count_fragments: int = MIN_COUNT_FRAGMENTS,
        output_path: str | None = None,
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
        """
        super().__init__(output_path=output_path)
        self._min_count_fragments = min_count_fragments

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        mol_smiles = [
            Chem.MolFromSmiles(smiles)
            for smiles in smiles_list
            if smiles != "None"
        ]
        mol_smiles = [mol for mol in mol_smiles if mol is not None]
        fragments = []
        for mol in mol_smiles:
            fragments.extend(get_fragment(mol))
        fragments, over_represented_fragments = self._from_list_to_count_df(
            smiles_list,
            fragments,
        )
        self._fragments_df = fragments
        return fragments, over_represented_fragments

    def _count_substructure_in_smiles(self, smiles_list, fragment):
        """Check if ngram is in smiles"""
        if not hasattr(self, "_mol_smiles"):
            self._mol_smiles = [
                Chem.MolFromSmiles(smiles)
                for smiles in smiles_list
                if smiles != "None"
            ]
            self._mol_smiles = [mol for mol in self._mol_smiles if mol is not None]
        return len(
            [
                mol
                for mol in self._mol_smiles 
                if mol.HasSubstructMatch(Chem.MolFromSmarts(fragment))
            ]
        )


    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        if smiles is None and mol is None:
            return False
        if smiles is not None:
            mol = Chem.MolFromSmiles(smiles)
        if fragment is None or mol is None:
            return False
        try:
            return mol.HasSubstructMatch(Chem.MolFromSmarts(fragment))
        except ValueError:
            logging.exception(
                "Error in substructure match for fragment: %s", fragment
            )
            return False


def delete_non_ring_atoms(mol: Chem.Mol) -> Chem.Mol:
    """Delete non-ring atoms from the molecule."""
    atoms_to_delete = [
        atom.GetIdx() for atom in mol.GetAtoms() if not atom.IsInRing()
    ]
    mol_rw = Chem.RWMol(mol)
    mol_rw.BeginBatchEdit()
    for atom in atoms_to_delete:
        mol_rw.RemoveAtom(atom)
    mol_rw.CommitBatchEdit()
    return Chem.Mol(mol_rw)


def get_fragment(mol: Chem.Mol) -> list[str]:
    """Extract fragments from a molecule using MacFrag and fused ring fragmentation."""
    if mol is None:
        return []
    smarts_list = [
        Chem.MolToSmarts(mol_frag)
        for mol_frag in MacFrag(
            mol,
            maxBlocks=MAX_BLOCKS,
            maxSR=MAX_SR,
            asMols=True,
            minFragAtoms=MIN_FRAG_ATOMS,
        )
    ]
    fragments = set(smarts_list)
    for smarts in smarts_list:
        mol_frag = Chem.MolFromSmarts(smarts)
        if (
            mol_frag is not None
            and mol_frag.GetNumAtoms() < MAX_FRAGMENT_ATOMS
            and mol_frag.GetNumAtoms() > MIN_FRAG_ATOMS
        ):
            try:
                new_frag = fragment_mols_fused_ring(mol_frag)
                fragments.update(
                    [
                        Chem.MolToSmarts(frag)
                        for frag in new_frag
                        if frag is not None
                    ]
                )
            except (ValueError, TypeError):
                logging.exception(
                    "Error in fused ring fragmentation for fragment: %s",
                    smarts,
                )
                continue
    fragment_ring_only = [
        delete_non_ring_atoms(Chem.MolFromSmarts(fragment))
        for fragment in fragments
    ]
    fragments.update(
        [Chem.MolToSmarts(fragment) for fragment in fragment_ring_only]
    )
    fragments = [fragment for fragment in fragments if "." not in fragment]
    fragments = [
        fragment
        for fragment in fragments
        if len(fragment) > MIN_FRAG_ATOMS * 4
    ]
    mol_fragments = [
        Chem.MolFromSmarts(fragment)
        for fragment in fragments
        if Chem.MolFromSmarts(fragment) is not None
    ]
    fragments_cleaned = []
    for mol_fragment in mol_fragments:
        if mol_fragment is not None:
            try:
                if mol.HasSubstructMatch(mol_fragment):
                    fragments_cleaned.append(Chem.MolToSmarts(mol_fragment))
            except (ValueError, TypeError):
                logging.exception(
                    "Issue with fragment: %s; Error in matching fragment.",
                    Chem.MolToSmarts(mol_fragment),
                )
                continue
    return fragments_cleaned
