# Generated by Copilot
import logging

import pandas as pd
from rdkit import Chem

from navidiv.fragment.utils import (
    GetRingSystems,
    get_fragment_not_in_scaffolds,
    transform_molecules,
)
from navidiv.scorer import BaseScore

DIFF_MEDIAN_SCOR_LIMIT = 0.2
MIN_COUNT_FRAGMENTS = 2
MAX_BLOCKS = 100
MAX_SR = 1
MIN_FRAG_ATOMS = 8
MAX_FRAGMENT_ATOMS = 40


class FragmentScorer(BaseScore):
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        min_count_fragments: int = MIN_COUNT_FRAGMENTS,
        output_path: str | None = None,
        tranfomation_mode: str = "none",
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
            tranfomation_mode (str): Transformation mode for fragments.
                the different modes are:
                - "none": No transformation
                - "basic_framework": Anonymize atoms and set all bonds to single.
                - "elemental_wire_frame": Set all bonds to single, keep atom types.
                - "basic_wire_frame": Set all atoms to carbon, keep bond orders.
                - "none": No transformation, return the original molecule.

        """
        super().__init__(output_path=output_path)
        self._min_count_fragments = min_count_fragments
        self._min_num_atoms_fragments = MIN_FRAG_ATOMS
        self.tranfomation_mode = tranfomation_mode
        self.fragment_dict = {}
        self._csv_name = f"fragments_{self.tranfomation_mode}"

    def update_transformation_mode(self, transformation_mode: str) -> None:
        """Update the transformation mode for fragment scoring.

        Args:
            transformation_mode (str): The new transformation mode.
        """
        self.tranfomation_mode = transformation_mode
        self._csv_name = f"fragments_{self.tranfomation_mode}"
        self.fragment_dict = {}

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        fragments = []
        fragments = self.get_fragments(smiles_list)

        fragments, over_represented_fragments = self._from_list_to_count_df(
            smiles_list,
            fragments,
        )
        self._fragments_df = fragments
        return fragments, over_represented_fragments

    def _count_substructure_in_smiles(self, smiles_list, fragment):
        """Check if ngram is in smiles"""
        return len(
            [
                smiles
                for smiles in smiles_list
                if self._comparison_function(smiles, fragment)
            ]
        )

    def get_fragments(self, smiles_list: list[str]) -> list[str]:
        """Extract fragments from a list of SMILES strings using MacFrag and fused ring fragmentation."""
        mol_smiles = [
            Chem.MolFromSmiles(smiles)
            for smiles in smiles_list
            if smiles != "None"
        ]
        mol_smiles = [mol for mol in mol_smiles if mol is not None]
        self._mol_smiles = mol_smiles
        fragments = []
        for smiles in smiles_list:
            if smiles in self.fragment_dict:
                fragments.extend(self.fragment_dict[smiles])
                continue
            mol = Chem.MolFromSmiles(smiles)
            if mol is None:
                self.fragment_dict[smiles] = []
                continue
            fragments_mol = self._get_fragment(mol)
            self.fragment_dict[smiles] = fragments_mol
            fragments.extend(fragments_mol)
        self._fragments = fragments
        return fragments

    def _get_fragment(self, mol: Chem.Mol) -> list[str]:
        """Get fragments from a molecule."""
        fragments_mol = []
        new_nodes_copy = get_fragment_not_in_scaffolds(
            mol, self._min_num_atoms_fragments
        )
        rings = GetRingSystems(mol)
        for new_nodes in rings:
            mol_node = Chem.MolFromSmiles(new_nodes)
            if mol_node is None:
                logging.warning(
                    "Ring transformation failed for: %s", new_nodes
                )
                continue
            if mol_node.GetNumAtoms() > self._min_num_atoms_fragments:
                new_nodes_copy.append(new_nodes)
        for fragment in new_nodes_copy:
            mol_fragment = Chem.MolFromSmiles(fragment)
            mol_fragment = transform_molecules(
                mol_fragment, self.tranfomation_mode
            )
            if mol_fragment is None:
                logging.warning(
                    "Fragment transformation failed for: %s", fragment
                )
                continue
            smiles_transformed = Chem.MolToSmiles(
                mol_fragment, isomericSmiles=True
            )
            if smiles_transformed is None:
                logging.warning(
                    "Fragment transformation failed for: %s", fragment
                )
                continue
            fragments_mol.append(smiles_transformed)
        return fragments_mol

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        if smiles not in self.fragment_dict:
            self.get_fragments([smiles])
        return fragment in self.fragment_dict[smiles]

    def additional_metrics(self):
        """Calculate additional metrics for the scorer."""
        from collections import Counter

        count_fragments = Counter(self._fragments)
        ngrams_above_10 = {
            ngram: count
            for ngram, count in count_fragments.items()
            if count > 10
        }
        ngrams_above_5 = {
            ngram: count
            for ngram, count in count_fragments.items()
            if count > 5
        }
        ngrams_below_2 = {
            ngram: count
            for ngram, count in count_fragments.items()
            if count < 2
        }

        return {
            "Appeared more than 10 times": len(ngrams_above_10),
            "Appeared more than 5 times": len(ngrams_above_5),
            "Appeared once": len(ngrams_below_2),
        }
