"""function to plot results from a CSV file using Streamlit and Plotly"""

import ast

import pandas as pd
import plotly.express as px
import streamlit as st
from rdkit import Chem

from navidiv.app_utils.data_filter import data_filter
from navidiv.app_utils.molecules_drawing import draw_molecule


def cumulative_sum_per_substructure(df, col):
    """Computes the cumulative sum of a specified column grouped by 'Substructure'.
    Returns a DataFrame with the cumulative sum added as a new column.
    """
    try:
        df["cumulative_" + col] = df.groupby("Substructure")[col].cumsum()
    except Exception as e:
        print(
            f"Error computing cumulative sum for column {col} by Substructure: {e}"
        )
    return df


def flatten_list_columns(df):
    """Generated by Copilot
    Flattens all columns in the DataFrame that contain lists (as strings or actual lists).
    Returns a DataFrame with only single elements per row.
    """
    df_copy = df.copy()
    # Convert stringified lists to actual lists
    for col in df_copy.columns:
        if (
            df_copy[col]
            .apply(lambda x: isinstance(x, str) and x.strip().startswith("["))
            .any()
        ):
            try:
                df_copy[col] = df_copy[col].apply(
                    lambda x: ast.literal_eval(x)
                    if isinstance(x, str) and x.strip().startswith("[")
                    else x
                )
            except Exception as e:
                # Log error with contextual information
                print(f"Error parsing column {col}: {e}")
    # Find columns that are lists
    list_cols = [
        col
        for col in df_copy.columns
        if df_copy[col].apply(lambda x: isinstance(x, list)).any()
    ]
    # Explode all list columns
    # for col in list_cols:
    df_copy = df_copy.explode(list_cols)
    for col in list_cols:
        # Convert the column to numeric if possible
        try:
            df_copy[col] = pd.to_numeric(df_copy[col], errors="coerce")
        except Exception as e:
            st.warning(f"Error converting column {col} to numeric: {e}")
        # Compute cumulative sum for the column
        df_copy = cumulative_sum_per_substructure(df_copy, col)

    list_cols = list_cols + [
        "cumulative_" + col for col in list_cols
    ]  # Add cumulative columns to the list of columns
    return df_copy, list_cols


def plot_list_column_distribution(df):
    """Generated by Copilot
    Plots the distribution of list lengths for a selected list column.
    """
    # Find columns where the first row is a list and has more than 3 elements

    df_list_columns, list_columns = flatten_list_columns(df)
    # list_columns = df_list_columns.columns
    st.write("#### List Column Distribution")
    col1, col2 = st.columns(2)
    with col1:
        selected_col_x = st.selectbox(
            "x axis", list_columns, key="list_col_select_1"
        )
    with col2:
        selected_col_y = st.selectbox(
            "y axis", list_columns, key="list_col_select"
        )
    df_list_columns.sort_values(
        by=[selected_col_x],
        ascending=True,
        inplace=True,
    )

    fig = px.line(
        df_list_columns,
        x=selected_col_x,
        y=selected_col_y,
        color="index",
        symbol="index",
        # labels={"x": selected_col_x, "y": selected_col_y},
        # title=f"List Lengths in '{selected_col_x}' vs '{selected_col_y}'",
    )

    # fig = px.histogram(list_lengths, nbins=20, labels={'value': 'List Length'}, title=f"Distribution of list lengths in '{selected_col}'")
    st.plotly_chart(fig, use_container_width=True, key="list_col_dist")


def plot_results(file_path):
    try:
        st.session_state.df = pd.read_csv(file_path, index_col=False)
        st.session_state.df["index"] = st.session_state.df.index
        st.write("#### Data Preview")
        st.dataframe(st.session_state.df.head(2))
    except Exception as e:
        st.error(f"Error reading CSV file: {e}")
        return
    if len(st.session_state.df) == 0:
        st.warning("No data to display.")
        return
    filtered_data = data_filter(st.session_state.df, key="results")
    col_not_object = [
        col
        for col in filtered_data.columns
        if filtered_data[col].dtype != "object"
    ]

    col_not_object = col_not_object + [
        col
        for col in filtered_data.columns
        if isinstance(filtered_data[col].values[0], str)
        and len(set(filtered_data[col].values)) < 100
    ]  # avoid color scale for large number of unique values

    columns = filtered_data.columns.tolist()
    col_columns_selection = st.columns(3)
    with col_columns_selection[0]:
        x_column = st.selectbox(
            "X-axis column",
            columns,
            index=len(columns) - 2,
        )
    with col_columns_selection[1]:
        y_column = st.selectbox("Y-axis column ", columns)
    with col_columns_selection[2]:
        hue_column = st.selectbox(
            "Hue column",
            col_not_object,
        )
    filtered_data.reset_index(drop=True, inplace=True)
    fig = px.scatter(
        filtered_data,
        x=x_column,
        y=y_column,
        color=hue_column if hue_column else None,
        hover_data=[filtered_data.index],
    )
    selected_points = st.plotly_chart(
        fig,
        use_container_width=True,
        height=200,
        key="iris_3",
        on_select="rerun",
    )
    if len(selected_points.selection.points) > 0:
        st.session_state.hover_indexs = [
            selected_points.selection.points[x]["customdata"]["0"]
            for x in range(len(selected_points.selection.points))
        ]
        st.dataframe(
            filtered_data.iloc[st.session_state.hover_indexs][
                list(set(["Substructure", x_column, y_column, hue_column]))
            ]
        )
        smiles_column = "Substructure"  # get_smiles_column(filtered_data)
        if smiles_column in filtered_data.columns:
            img = draw_molecule(
                Chem.MolFromSmiles(
                    filtered_data.iloc[st.session_state.hover_indexs][
                        smiles_column
                    ].values[0]
                )
            )
            if img is not None:
                st.image(
                    img,
                    caption=f" {filtered_data.iloc[st.session_state.hover_indexs][smiles_column].values[0]}",
                )
        st.session_state.list_of_molecules_containing_fragment = eval(
            filtered_data.iloc[st.session_state.hover_indexs][
                "Molecules containing fragment"
            ].values[0]
        )
        # st.write(
        #    f"List of molecules containing fragment: {list_of_molecules_containing_fragment}"
        # )
    # After the iris_3 chart, plot list column distribution if available
    plot_list_column_distribution(filtered_data)


def plot_step_results(file_path):
    try:
        st.session_state.df = pd.read_csv(file_path, index_col=False)
        st.session_state.df["index"] = st.session_state.df.index
        st.write("#### Data Preview")
        st.dataframe(st.session_state.df.head(2))
    except Exception as e:
        st.error(f"Error reading CSV file: {e}")
        return
    if len(st.session_state.df) == 0:
        st.warning("No data to display.")
        return
    filtered_data = data_filter(st.session_state.df, key="results_step")
    col_not_object = [
        col
        for col in filtered_data.columns
        if filtered_data[col].dtype != "object"
    ]

    col_not_object = col_not_object + [
        col
        for col in filtered_data.columns
        if isinstance(filtered_data[col].values[0], str)
        and len(set(filtered_data[col].values)) < 100
    ]  # avoid color scale for large number of unique values

    columns = filtered_data.columns.tolist()
    col_columns_selection = st.columns(3)
    with col_columns_selection[0]:
        x_column = st.selectbox(
            "X-axis column",
            columns,
            index=len(columns) - 4,
            key="x_column_steps",
        )
    with col_columns_selection[1]:
        y_column = st.selectbox("Y-axis column", columns, key="y_column_steps")
    with col_columns_selection[2]:
        hue_column = st.selectbox(
            "Hue column",
            col_not_object,
            key="hue_column_steps",
        )
    filtered_data.reset_index(drop=True, inplace=True)
    fig = px.scatter(
        filtered_data,
        x=x_column,
        y=y_column,
        color=hue_column if hue_column else None,
        hover_data=[filtered_data.index],
    )
    selected_points = st.plotly_chart(
        fig,
        use_container_width=True,
        height=200,
        key="iris_2",
        on_select="rerun",
    )
    """
    if len(selected_points.selection.points) > 0:
        st.session_state.hover_indexs = [
            selected_points.selection.points[x]["customdata"]["0"]
            for x in range(len(selected_points.selection.points))
        ]
        st.dataframe(
            filtered_data.iloc[st.session_state.hover_indexs][
                list(set(["Substructure", x_column, y_column, hue_column]))
            ]
        )
        smiles_column = "Substructure"  # get_smiles_column(filtered_data)
        if smiles_column in filtered_data.columns:
            img = draw_molecule(
                Chem.MolFromSmiles(
                    filtered_data.iloc[st.session_state.hover_indexs][
                        smiles_column
                    ].values[0]
                )
            )
            if img is not None:
                st.image(
                    img,
                    caption=f" {filtered_data.iloc[st.session_state.hover_indexs][smiles_column].values[0]}",
                )
"""
