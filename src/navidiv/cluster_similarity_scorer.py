# Generated by Copilot

import numpy as np
import pandas as pd
from rdkit import Chem, DataStructs
from rdkit.Chem import rdFingerprintGenerator

from navidiv.scorer import BaseScore


def get_fingerprints(molecules):
    """Generate Morgan fingerprints for a list of molecules."""
    mfpgen = rdFingerprintGenerator.GetMorganGenerator(
        radius=5, fpSize=2048, countSimulation=True
    )
    fingerprints = [mfpgen.GetFingerprint(mol) for mol in molecules]
    return fingerprints


def calculate_similarity(fp_list1, fp_list2):
    """Calculate the Tanimoto similarity between two sets of fingerprints."""
    return np.array(
        [DataStructs.BulkTanimotoSimilarity(fp1, fp_list2) for fp1 in fp_list1]
    )


class ClusterSimScorer(BaseScore):
    """Handles fragment scoring and analysis for molecular datasets."""

    def __init__(
        self,
        threshold: float = 0.8,
        output_path: str | None = None,
    ) -> None:
        """Initialize FragmentScore.

        Args:
            min_count_fragments (int): Minimum count for fragments to be
                considered.
            output_path (str | None): Path to save output files.
        """
        super().__init__(output_path=output_path)
        self._csv_name = "clusters"
        self._similarity = []
        self.threshold = threshold
        self._min_count_fragments = 0

    def get_clusters(self, similarity):
        """Get clusters of similar molecules based on a similarity threshold."""
        #np.fill_diagonal(similarity, 0)
        clusters = set()

        for i in range(similarity.shape[0]):
            if not np.any(similarity[i, :i] > self.threshold):
                clusters.add(i)
        return clusters

    def get_count(self, smiles_list: list[str]) -> tuple[pd.DataFrame, None]:
        """Calculate the percentage of each fragment in the dataset.

        Args:
            smiles_list (list[str]): List of SMILES strings.

        Returns:
            tuple: DataFrame with fragment info, None (for compatibility)
        """
        if not hasattr(self, "_mol_smiles"):
            self._mol_smiles = [
                Chem.MolFromSmiles(smiles)
                for smiles in smiles_list
                if smiles != "None"
            ]
            self._mol_smiles = [
                mol for mol in self._mol_smiles if mol is not None
            ]
            self._smiles_list = [
                smiles
                for smiles in smiles_list
                if smiles != "None" and Chem.MolFromSmiles(smiles) is not None
            ]

            print("Number of valid molecules:", len(self._mol_smiles))
        search_fps = get_fingerprints(self._mol_smiles)

        self._similarity_to_itself = calculate_similarity(
            search_fps, search_fps
        )
        df_similarity = pd.DataFrame(
            self._similarity_to_itself,
        )
        df_similarity.to_csv(self._output_path + "/similarity.csv")
        clusters = self.get_clusters(self._similarity_to_itself)
        clusters_smiles = [self._smiles_list[i] for i in clusters]
        fragments, over_represented_fragments = self._from_list_to_count_df(
            self._smiles_list,
            clusters_smiles,
            total_number_of_ngrams=len(self._smiles_list),
        )
        self._fragments_df = fragments
        return fragments, over_represented_fragments

    def _cout_substructure_in_smiles(self, smiles_list, ngram):
        """Check if ngram is in smiles"""
        # np.fill_diagonal(self._similarity_to_itself, 0)
        ngram_index = self._smiles_list.index(ngram)
        return 1 + len(
            [
                i
                for i in range(self._similarity_to_itself.shape[0])
                if self._similarity_to_itself[ngram_index, i] > self.threshold
            ]
        )

    def _comparison_function(
        self,
        smiles: str | None = None,
        fragment: str | None = None,
        mol: Chem.Mol | None = None,
    ) -> bool:
        """Check if the fragment is present in the SMILES string or molecule."""
        if fragment in self._smiles_list:
            ngram_index = self._smiles_list.index(fragment)
        else:
            return False
        if smiles in self._smiles_list:
            smiles_index = self._smiles_list.index(smiles)
        else:
            return False
        #print(f"ngram_index: {ngram_index}, smiles_index: {smiles_index}")
        return (
            self._similarity_to_itself[ngram_index, smiles_index]
            > self.threshold
        )

    def additional_metrics(self):
        """Calculate additional metrics for the scorer."""
        np.fill_diagonal(self._similarity_to_itself, 0)
        mean_distance = np.mean(self._similarity_to_itself)
        std_distance = np.std(self._similarity_to_itself)
        return {
            "mean_distance": mean_distance,
            "std_distance": std_distance,
        }