# Generated by Copilot


from rdkit import Chem
from rdkit.Chem import rdmolops
from rdkit.Chem.Scaffolds import MurckoScaffold
from rdkit.Chem import Draw


class ScaffoldModeOption:
    SCAFFOLD = "scaffold"
    MURCKO_FRAMEWORK = "murcko_framework"
    BASIC_WIRE_FRAME = "basic_wire_frame"
    ELEMENTAL_WIRE_FRAME = "elemental_wire_frame"
    BASIC_FRAMEWORK = "basic_framework"


class ScaffoldGenerator:
    """Generates different molecule scaffolds and frameworks using RDKit.
    """

    SCAFFOLD_ATOM_COUNTER_PROPERTY = "SCAFFOLD_ATOM_COUNTER_PROPERTY"

    def __init__(self):
        # Settings
        self.determine_aromaticity_setting: bool = True
        self.scaffold_mode_setting: str = ScaffoldModeOption.SCAFFOLD
        self._tmp_log_exception_counter: int = 0

    def set_scaffold_mode_setting(self, mode: str):
        self.scaffold_mode_setting = mode

    def get_scaffold(self, mol: Chem.Mol) -> Chem.Mol:
        """Generates the selected scaffold type for the entered molecule and returns it.
        """
        if self.scaffold_mode_setting == ScaffoldModeOption.MURCKO_FRAMEWORK:
            return MurckoScaffold.GetScaffoldForMol(mol)
        if self.scaffold_mode_setting == ScaffoldModeOption.SCAFFOLD:
            # For demonstration, use Murcko as base, but keep non-single bonded atoms attached to rings/linkers
            return MurckoScaffold.GetScaffoldForMol(mol)
        if self.scaffold_mode_setting == ScaffoldModeOption.BASIC_WIRE_FRAME:
            # Anonymize atoms and set all bonds to single
            scaffold = MurckoScaffold.GetScaffoldForMol(mol)
            for atom in scaffold.GetAtoms():
                atom.SetAtomicNum(6)
            for bond in scaffold.GetBonds():
                bond.SetBondType(Chem.BondType.SINGLE)
            return scaffold
        if (
            self.scaffold_mode_setting
            == ScaffoldModeOption.ELEMENTAL_WIRE_FRAME
        ):
            # Set all bonds to single, keep atom types
            scaffold = rdmolops.GetScaffoldForMol(mol)
            for bond in scaffold.GetBonds():
                bond.SetBondType(Chem.BondType.SINGLE)
            return scaffold
        if self.scaffold_mode_setting == ScaffoldModeOption.BASIC_FRAMEWORK:
            # Set all atoms to carbon, keep bond orders
            scaffold = rdmolops.GetScaffoldForMol(mol)
            for atom in scaffold.GetAtoms():
                atom.SetAtomicNum(6)
            return scaffold
        raise ValueError("Unknown scaffold mode")

    def get_rings(self, mol: Chem.Mol) -> list[Chem.Mol]:
        """Extracts the individual rings from the scaffold of the given molecule.
        """
        scaffold = self.get_scaffold(mol)
        ri = scaffold.GetRingInfo()
        rings = []
        for ring in ri.AtomRings():
            ring_atoms = [scaffold.GetAtomWithIdx(idx) for idx in ring]
            emol = Chem.RWMol()
            idx_map = {}
            for atom in ring_atoms:
                idx = emol.AddAtom(Chem.Atom(atom.GetAtomicNum()))
                idx_map[atom.GetIdx()] = idx
            for i, atom in enumerate(ring_atoms):
                for j in range(i + 1, len(ring_atoms)):
                    if scaffold.GetBondBetweenAtoms(
                        atom.GetIdx(), ring_atoms[j].GetIdx()
                    ):
                        emol.AddBond(
                            idx_map[atom.GetIdx()],
                            idx_map[ring_atoms[j].GetIdx()],
                            Chem.BondType.SINGLE,
                        )
            rings.append(emol.GetMol())
        return rings

    def get_side_chains(self, mol: Chem.Mol) -> list[Chem.Mol]:
        """Outputs all fragments that are not contained in the generated scaffold in contrast to the unchanged molecule.
        """
        return []
        mol_copy = Chem.Mol(mol)
        scaffold = self.get_scaffold(mol_copy)
        side_chains = Chem.FragmentOnBonds(
            mol_copy,
            [
                b.GetIdx()
                for b in mol.GetBonds()
                if not scaffold.GetBondBetweenAtoms(
                    b.GetBeginAtomIdx(), b.GetEndAtomIdx()
                )
            ],
        )
        frags = Chem.GetMolFrags(side_chains, asMols=True)
        # Remove single hydrogens
        return [
            frag
            for frag in frags
            if frag.GetNumAtoms() > 1
            or frag.GetAtomWithIdx(0).GetAtomicNum() != 1
        ]

    def get_linkers(self, mol: Chem.Mol) -> list[Chem.Mol]:
        """Returns the linkers of the molecule as a fragment list.
        """
        return []
        scaffold = self.get_scaffold(mol)
        rings = self.get_rings(mol)
        ring_atoms = set()
        for ring in rings:
            ring_atoms.update([atom.GetIdx() for atom in ring.GetAtoms()])
        linker_atoms = [
            atom
            for atom in scaffold.GetAtoms()
            if atom.GetIdx() not in ring_atoms
        ]
        if not linker_atoms:
            return []
        emol = Chem.RWMol()
        idx_map = {}
        for atom in linker_atoms:
            idx = emol.AddAtom(Chem.Atom(atom.GetAtomicNum()))
            idx_map[atom.GetIdx()] = idx
        for atom in linker_atoms:
            for nbr in atom.GetNeighbors():
                if nbr.GetIdx() in idx_map:
                    emol.AddBond(
                        idx_map[atom.GetIdx()],
                        idx_map[nbr.GetIdx()],
                        Chem.BondType.SINGLE,
                    )
        return [emol.GetMol()]

    def apply_enumerative_removal(self, mol: Chem.Mol) -> list[Chem.Mol]:
        """Iteratively removes the terminal rings. All resulting scaffolds are returned. Duplicates are not permitted.
        """
        # This is a simplified version: just return the scaffold and its rings for demonstration
        scaffolds = [self.get_scaffold(mol)]
        #scaffolds.extend(self.get_rings(mol))
        for i in range(len(scaffolds)):
            new_scaffold = self.get_scaffold(scaffolds[i])
            if new_scaffold is not None and new_scaffold not in scaffolds:
                print(f"Adding new scaffold: {Chem.MolToSmiles(new_scaffold)}")
                Chem.SanitizeMol(new_scaffold)
                scaffolds.append(new_scaffold)
        return scaffolds

    @staticmethod
    def save_molecules_image(mols, legends, filename, mols_per_row=4, sub_img_size=(200, 200)):
        """Save a list of molecules as a grid image with legends."""
        # Generated by Copilot
        img = Draw.MolsToGridImage(
            mols,
            legends=legends,
            molsPerRow=mols_per_row,
            subImgSize=sub_img_size,
            useSVG=False
        )
        img.save(filename)


# --- Simple test suggestion ---

if __name__ == "__main__":
    # Example molecule: caffeine
    smiles = "Cn1cnc2c1c(=O)n(C)c(=O)n2CC3CC(C3)C(=O)N(C)C"
    mol = Chem.MolFromSmiles(smiles)
    gen = ScaffoldGenerator()

    print("Scaffold SMILES:")
    scaffold = gen.get_scaffold(mol)
    print(Chem.MolToSmiles(scaffold))

    print("\nRings:")
    rings = gen.get_rings(mol)
    for ring in rings:
        print(Chem.MolToSmiles(ring))

    print("\nSide chains:")
    side_chains = gen.get_side_chains(mol)
    for sc in side_chains:
        print(Chem.MolToSmiles(sc))

    print("\nLinkers:")
    linkers = gen.get_linkers(mol)
    for linker in linkers:
        print(Chem.MolToSmiles(linker))

    print("\nEnumerative removal:")
    enumerative = gen.apply_enumerative_removal(mol)
    for frag in enumerative:
        print(Chem.MolToSmiles(frag))

    # --- Save image of all molecules: initial, scaffold, rings, enumerative removal ---
    mols = [mol, scaffold] + rings + enumerative
    legends = (
        ["Initial"] +
        ["Scaffold"] +
        [f"Ring {i+1}" for i in range(len(rings))] +
        [f"Enum {i+1}" for i in range(len(enumerative))]
    )
    ScaffoldGenerator.save_molecules_image(mols, legends, "scaffold_overview.png")
    print("\nSaved image as scaffold_overview.png")
